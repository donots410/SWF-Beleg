/*
 * generated by Xtext 2.13.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.Atom;
import org.xtext.example.mydsl.myDsl.Clause;
import org.xtext.example.mydsl.myDsl.Exquery;
import org.xtext.example.mydsl.myDsl.Fact;
import org.xtext.example.mydsl.myDsl.Folge;
import org.xtext.example.mydsl.myDsl.Functor;
import org.xtext.example.mydsl.myDsl.List;
import org.xtext.example.mydsl.myDsl.ListOpt1;
import org.xtext.example.mydsl.myDsl.ListOpt2;
import org.xtext.example.mydsl.myDsl.ListOpt3;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Predicate;
import org.xtext.example.mydsl.myDsl.Program;
import org.xtext.example.mydsl.myDsl.Prologdsl;
import org.xtext.example.mydsl.myDsl.Query;
import org.xtext.example.mydsl.myDsl.Rest;
import org.xtext.example.mydsl.myDsl.Rule;
import org.xtext.example.mydsl.myDsl.Term;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ATOM:
				sequence_Atom(context, (Atom) semanticObject); 
				return; 
			case MyDslPackage.CLAUSE:
				sequence_Clause(context, (Clause) semanticObject); 
				return; 
			case MyDslPackage.EXQUERY:
				sequence_Exquery(context, (Exquery) semanticObject); 
				return; 
			case MyDslPackage.FACT:
				sequence_Fact(context, (Fact) semanticObject); 
				return; 
			case MyDslPackage.FOLGE:
				sequence_Folge(context, (Folge) semanticObject); 
				return; 
			case MyDslPackage.FUNCTOR:
				sequence_Functor(context, (Functor) semanticObject); 
				return; 
			case MyDslPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case MyDslPackage.LIST_OPT1:
				sequence_ListOpt1(context, (ListOpt1) semanticObject); 
				return; 
			case MyDslPackage.LIST_OPT2:
				sequence_ListOpt2(context, (ListOpt2) semanticObject); 
				return; 
			case MyDslPackage.LIST_OPT3:
				sequence_ListOpt3(context, (ListOpt3) semanticObject); 
				return; 
			case MyDslPackage.PREDICATE:
				sequence_Predicate(context, (Predicate) semanticObject); 
				return; 
			case MyDslPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case MyDslPackage.PROLOGDSL:
				sequence_Prologdsl(context, (Prologdsl) semanticObject); 
				return; 
			case MyDslPackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case MyDslPackage.REST:
				sequence_Rest(context, (Rest) semanticObject); 
				return; 
			case MyDslPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case MyDslPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Atom returns Atom
	 *
	 * Constraint:
	 *     (at=ID | at=NUMBER2 | at=VARIABLE2)
	 */
	protected void sequence_Atom(ISerializationContext context, Atom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Clause
	 *
	 * Constraint:
	 *     (fact=Fact | rule=Rule)
	 */
	protected void sequence_Clause(ISerializationContext context, Clause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exquery returns Exquery
	 *
	 * Constraint:
	 *     query=Query
	 */
	protected void sequence_Exquery(ISerializationContext context, Exquery semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXQUERY__QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXQUERY__QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExqueryAccess().getQueryQueryParserRuleCall_1_0(), semanticObject.getQuery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Fact returns Fact
	 *
	 * Constraint:
	 *     predicate=Predicate
	 */
	protected void sequence_Fact(ISerializationContext context, Fact semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FACT__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FACT__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactAccess().getPredicatePredicateParserRuleCall_0_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Folge returns Folge
	 *
	 * Constraint:
	 *     (atom=Atom nextatom+=Atom*)
	 */
	protected void sequence_Folge(ISerializationContext context, Folge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Functor returns Functor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Functor(ISerializationContext context, Functor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctorAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ListOpt1 returns ListOpt1
	 *
	 * Constraint:
	 *     atom=Atom
	 */
	protected void sequence_ListOpt1(ISerializationContext context, ListOpt1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LIST_OPT1__ATOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LIST_OPT1__ATOM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListOpt1Access().getAtomAtomParserRuleCall_1_0(), semanticObject.getAtom());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rest returns ListOpt2
	 *     ListOpt2 returns ListOpt2
	 *
	 * Constraint:
	 *     (atom=Atom nextatom+=Atom*)
	 */
	protected void sequence_ListOpt2(ISerializationContext context, ListOpt2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rest returns ListOpt3
	 *     ListOpt3 returns ListOpt3
	 *
	 * Constraint:
	 *     (atom=Atom nextatom+=Atom*)
	 */
	protected void sequence_ListOpt3(ISerializationContext context, ListOpt3 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     List returns List
	 *
	 * Constraint:
	 *     (ka='[' (atom=Atom rest=Rest?)? kz=']')
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns Predicate
	 *
	 * Constraint:
	 *     (functor=Functor term=Term nextterm+=Term*)
	 */
	protected void sequence_Predicate(ISerializationContext context, Predicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     clause+=Clause+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Prologdsl returns Prologdsl
	 *
	 * Constraint:
	 *     (progam=Program exquery=Exquery)
	 */
	protected void sequence_Prologdsl(ISerializationContext context, Prologdsl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROLOGDSL__PROGAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROLOGDSL__PROGAM));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROLOGDSL__EXQUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROLOGDSL__EXQUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrologdslAccess().getProgamProgramParserRuleCall_0_0(), semanticObject.getProgam());
		feeder.accept(grammarAccess.getPrologdslAccess().getExqueryExqueryParserRuleCall_1_0(), semanticObject.getExquery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Query returns Query
	 *
	 * Constraint:
	 *     (predicate=Predicate nextpredicate+=Predicate*)
	 */
	protected void sequence_Query(ISerializationContext context, Query semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rest returns Rest
	 *
	 * Constraint:
	 *     opt=ListOpt1
	 */
	protected void sequence_Rest(ISerializationContext context, Rest semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REST__OPT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REST__OPT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRestAccess().getOptListOpt1ParserRuleCall_0_0(), semanticObject.getOpt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (predicate=Predicate query=Query)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RULE__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RULE__PREDICATE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RULE__QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RULE__QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleAccess().getPredicatePredicateParserRuleCall_0_0(), semanticObject.getPredicate());
		feeder.accept(grammarAccess.getRuleAccess().getQueryQueryParserRuleCall_2_0(), semanticObject.getQuery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns Term
	 *
	 * Constraint:
	 *     (term=Atom | term=List)
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
